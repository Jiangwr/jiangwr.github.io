---
layout: post
title: Scala 中的尾递归
subtitle: Excerpt from Soulshaping by Jeff Brown
---
先来一波"拷问"，什么是尾递归？尾递归的原理是什么？尾递归的使用有哪些注意事项？

<!--more-->

## 什么是尾递归

当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。

举个例子，普通的线形递归:

```
long Rescuvie(long n) {
//Rescuvie(n - 1) 方法的返回值需要与 n 做相乘运算，所以不是一个尾递归
    return (n == 1) ? 1 : n * Rescuvie(n - 1);
 
}
```

尾递归:

```
long TailRescuvie(long n, long a) {
//TailRescuvie(n - 1, a * n)方法是在函数最尾部调用,并且函数返回值不属于表达式的一部分，因此这是一个尾递归
    return (n == 1) ? a : TailRescuvie(n - 1, a * n);
 
}
 
 
long TailRescuvie(long n) {//封装用的
     
    return (n == 0) ? 1 : TailRescuvie(n, 1);
 
}
```

当n = 5时，线形递归的过程是这样子的:

```
Rescuvie(5)
{5 * Rescuvie(4)}
{5 * {4 * Rescuvie(3)}}
{5 * {4 * {3 * Rescuvie(2)}}}
{5 * {4 * {3 * {2 * Rescuvie(1)}}}}
{5 * {4 * {3 * {2 * 1}}}}
{5 * {4 * {3 * 2}}}
{5 * {4 * 6}}
{5 * 24}
120
```

当 n = 5 时，尾递归的过程是这样子的:

```
TailRescuvie(5)
TailRescuvie(5, 1)
TailRescuvie(4, 5)
TailRescuvie(3, 20)
TailRescuvie(2, 60)
TailRescuvie(1, 120)
120
```

由上面的过程可以看出，普通线形递归，为了保存数据，栈消耗的资源会越来越多，而尾递归则不会有这个问题。也正是因为这个特性，尾递归在大数据集的情况下也不会爆栈。

## 尾递归的原理

编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。

## 尾递归使用的注意事项

首先要知道不同的语言对尾递归的支持是不一样的。比如 Java 并没有尾递归优化，Scala 是有对尾递归进行优化的。

毕竟可以递归的问题，也都是可以使用循环的。所以在 Java 中，应该尽量多使用循环，少使用递归。使用递归就给线上过大的数据集造成爆栈埋雷了。

在 Scala 中，对于尾递归 Scala 编译器会自动进行优化为循环，但是最好在尾递归的函数上加上 @annotation.tailrec 注解，注解检查会告诉开发者是否可以进行尾递归优化，如果不能进行尾递归优化会编译报错。假如不加上 @annotation.tailrec  注解，若代码符合尾递归的要求，编译器依然会进行尾递归优化，若没有符合尾递归要求，则不会优化，按照普通的递归进行运行，此时的代码上线就存在数据集过大造成爆栈的危险。所以 Scala 中也不一定要使用尾递归，循环也一样可以搞定，若一定要用，则务必加上 @annotation.tailrec  注解。
